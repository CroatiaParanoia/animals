{"version":3,"sources":["pages/Playground/types.ts","hooks/useEventCallback.ts","pages/Playground/utils/drawTools.ts","pages/Playground/config.ts","pages/Playground/utils/tools.ts","pages/Playground/utils/drawPolygon.ts","pages/Playground/hooks/useAnimalCards.ts","pages/Playground/hooks/useAnimalTools.ts","pages/Playground/hooks/usePaperLayer.ts","pages/Playground/hooks/useDealCards.ts","pages/Playground/hooks/useAnimalGrid.ts","pages/Playground/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Camp","useEventCallback","fn","deps","ref","useRef","Error","useEffect","current","useCallback","tempFn","createPointer","x","y","Point","initCardArr","name","displayName","level","animalLayoutSize","startX","startY","rowCount","columnCount","gridWidth","gridSize","cardAreaSize","animalLayoutColor","hoverBorderColor","activeBorderColor","animalCardConfig","generateCards","createCampCard","camp","map","v","Alliance","concat","Orc","sort","Math","random","drawGrid","localInfoArr","i","innerStartY","push","width","height","innerStartX","shape","paper","Shape","Rectangle","Size","createSize","fillColor","Color","drawActiveBorder","location","color","size","cardAreaInfoArr","realSize","currentItem","find","centerOffsetX","centerOffsetY","getPointByLocation","centerX","centerY","path","Path","lineTo","leftBottomPath","clone","rotate","leftGroup","Group","rightGroup","borderGroup","data","drawCard","cardAreaInfo","cardSize","card","center","radius","centerPointer","cardPath","Circle","cardTextPath","PointText","Unknow","content","fontSize","justification","translate","getCardColor","shadowColor","shadowOffset","shadowBlur","useAnimalCards","cardLayer","drawCards","item","activate","pathArr","forEach","remove","useAnimalTools","getCardInfoByLocation","locationInfo","computedCardInfoByLocation","cardInfo","usePaperLayer","canvasEl","useState","gridLayer","operationLayer","layers","setLayers","setup","Layer","useDealCards","subCards","getCard","shift","resetCards","initCardAreaInfoArr","rowPoints","columnPoints","j","centerPointX","centerPointY","createCardAreaInfoArr","useAnimalGrid","activeArea","setActiveArea","hoverArea","setHoverArea","setCardAreaInfoArr","charts","fillCards","turnOverCard","newCardAreaInfoArr","onCardAreaMouseEnter","onCardAreaMouseLeave","undefined","onCardAreaMouseClick","drawGridByLayoutSize","drawCardAreaByLayoutSize","opacity","onClick","onMouseEnter","document","body","style","cursor","onMouseLeave","drawCardArea","Playground","id","App","className","Boolean","window","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.420b6645.chunk.js","sourcesContent":["export interface CardLocationInfo {\n  x: number;\n  y: number;\n}\n\nexport interface CardAreaInfo extends CardLocationInfo {\n  centerOffsetX: number;\n  centerOffsetY: number;\n  card?: CardInfo;\n}\n\nexport enum Camp {\n  Alliance = 'Alliance',\n  Orc = 'Orc',\n  Unknow = 'Unknow',\n}\n\nexport interface CardInfo {\n  name: string;\n  displayName: string;\n  level: number;\n  camp: Camp;\n}\n","import { useCallback, useRef, useEffect } from 'react';\n\nconst useEventCallback = <T extends (...args: any[]) => any>(fn: T, deps: unknown[]): T => {\n  const ref = useRef<T>((() => new Error('初始化未完成')) as any);\n\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn, ...deps]);\n\n  return useCallback(\n    (...args: Parameters<typeof fn>) => {\n      const tempFn = ref.current;\n      return tempFn(...args);\n    },\n    [ref]\n  ) as T;\n};\n\nexport default useEventCallback;\n","import { Point, Path, Shape, Size } from 'paper';\n\nexport const createPointer = (x: number, y: number) => {\n  return new Point(x, y);\n};\n\nexport const createSize = (width: number, height: number) => {\n  return new Size(width, height);\n};\n\nexport const createCircle = (center: paper.Point, radius: number) => {\n  return new Path.Circle(center, radius);\n};\n\nexport const createRectangle = (point: paper.Point, size: paper.Size) => {\n  return new Shape.Rectangle(point, size);\n};\n","export const initCardArr = [\n  { name: '象', displayName: '🐘', level: 7 },\n  { name: '狮', displayName: '🦁', level: 6 },\n  { name: '虎', displayName: '🐯', level: 5 },\n  { name: '豹', displayName: '🐆', level: 4 },\n  { name: '狼', displayName: '🐺', level: 3 },\n  { name: '狗', displayName: '🐶', level: 2 },\n  { name: '猫', displayName: '🐈', level: 1 },\n  { name: '鼠', displayName: '🐭', level: 0 },\n];\n\nexport const animalLayoutSize = {\n  startX: 50,\n  startY: 50,\n  rowCount: 3,\n  columnCount: 3,\n  gridWidth: 10,\n  gridSize: 100,\n  cardAreaSize: 70,\n};\n\nexport type AnimalLayoutSize = typeof animalLayoutSize;\n\nexport const animalLayoutColor = {\n  hoverBorderColor: 'rgba(0, 0, 128, 0.3)',\n  activeBorderColor: 'rgba(0, 0, 128, 0.8)',\n};\n\nexport const animalCardConfig = {\n  allianceCardColor: 'blue',\n  orcCardColor: 'red',\n  unknowCardColor: 'skyblue',\n\n  cardSize: 42,\n};\n","import { initCardArr, AnimalLayoutSize, animalCardConfig } from '../config';\nimport { CardAreaInfo, Camp, CardInfo } from '../types';\n\nexport const createCardAreaInfoArr = ({\n  rowCount,\n  columnCount,\n  startX,\n  startY,\n  gridSize,\n  gridWidth,\n}: Omit<AnimalLayoutSize, 'cardAreaSize'>): CardAreaInfo[] => {\n  const cardAreaInfoArr: CardAreaInfo[] = [];\n  const rowPoints = rowCount + 1;\n  const columnPoints = columnCount + 1;\n  for (let i = 0; i < rowPoints; i += 1) {\n    for (let j = 0; j < columnPoints; j += 1) {\n      const centerPointX = startX + i * (gridWidth + gridSize) + gridWidth / 2;\n      const centerPointY = startY + j * (gridWidth + gridSize) + gridWidth / 2;\n      cardAreaInfoArr.push({\n        x: i,\n        y: j,\n        centerOffsetX: centerPointX,\n        centerOffsetY: centerPointY,\n      });\n    }\n  }\n\n  return cardAreaInfoArr;\n};\n\nexport const generateCards = (): CardInfo[] => {\n  const createCampCard = (camp: Camp) => initCardArr.map((v) => ({ ...v, camp }));\n  return createCampCard(Camp.Alliance)\n    .concat(createCampCard(Camp.Orc))\n    .sort(() => Math.random() - 0.5);\n};\n\nexport const fillCards = (cardAreaInfoArr: CardAreaInfo[]) => {\n  const charts = generateCards().map((item) => ({ ...item, camp: Camp.Unknow }));\n\n  return cardAreaInfoArr.map((v, i) => {\n    return {\n      ...v,\n      card: charts[i],\n    };\n  });\n};\n\nexport const getCardColor = (camp: Camp): string => {\n  switch (camp) {\n    case Camp.Alliance:\n      return animalCardConfig.allianceCardColor;\n    case Camp.Orc:\n      return animalCardConfig.orcCardColor;\n    default:\n      return animalCardConfig.unknowCardColor;\n  }\n};\n","import paper from 'paper';\nimport { createCircle, createPointer, createSize } from './drawTools';\nimport { CardAreaInfo, CardLocationInfo, Camp } from '../types';\nimport { AnimalLayoutSize, animalCardConfig } from '../config';\nimport { getCardColor } from './tools';\n\nexport const drawGrid = ({\n  startY,\n  startX,\n  rowCount,\n  columnCount,\n  gridSize,\n  gridWidth,\n}: Omit<AnimalLayoutSize, 'cardAreaSize'>): paper.Shape[] => {\n  const localInfoArr = [];\n\n  for (let i = 0; i < columnCount + 1; i += 1) {\n    const innerStartY = startY + i * (gridSize + gridWidth);\n    localInfoArr.push({\n      x: startX,\n      y: innerStartY,\n      width: rowCount * (gridSize + gridWidth) + gridWidth,\n      height: gridWidth,\n    });\n  }\n  for (let i = 0; i < rowCount + 1; i += 1) {\n    const innerStartX = startX + i * (gridSize + gridWidth);\n\n    localInfoArr.push({\n      x: innerStartX,\n      y: startY,\n      width: gridWidth,\n      height: columnCount * (gridSize + gridWidth) + gridWidth,\n    });\n  }\n\n  return localInfoArr.map(({ x, y, width, height }) => {\n    const shape = new paper.Shape.Rectangle(createPointer(x, y), createSize(width, height));\n    shape.fillColor = new paper.Color(1, 0, 0, 0.3);\n    return shape;\n  });\n};\n\ninterface DrawCardArea {\n  cardAreaInfoArr: CardAreaInfo[];\n  cardAreaSize: number;\n  onCardAreaMouseClick?: (location: CardLocationInfo) => void;\n  onCardAreaMouseEnter?: (location: CardLocationInfo) => void;\n  onCardAreaMouseLeave?: (location: CardLocationInfo) => void;\n}\n\nexport const drawCardArea = ({\n  cardAreaInfoArr,\n  cardAreaSize,\n  onCardAreaMouseClick,\n  onCardAreaMouseEnter,\n  onCardAreaMouseLeave,\n}: DrawCardArea): paper.Shape[] => {\n  return cardAreaInfoArr.map((item) => {\n    const x = item.centerOffsetX - cardAreaSize / 2;\n    const y = item.centerOffsetY - cardAreaSize / 2;\n    const locationInfo: CardLocationInfo = { x: item.x, y: item.y };\n\n    const shape = new paper.Shape.Rectangle(\n      new paper.Point(x, y),\n      new paper.Size(cardAreaSize, cardAreaSize),\n    );\n    shape.fillColor = new paper.Color(1, 0, 0, 1);\n    shape.opacity = 0;\n    shape.radius = cardAreaSize / 2;\n\n    shape.onClick = () => {\n      onCardAreaMouseClick?.(locationInfo);\n    };\n    shape.onMouseEnter = () => {\n      onCardAreaMouseEnter?.(locationInfo);\n      document.body.style.cursor = 'pointer';\n    };\n    shape.onMouseLeave = () => {\n      onCardAreaMouseLeave?.(locationInfo);\n      document.body.style.cursor = 'default';\n    };\n\n    shape.data = locationInfo;\n    return shape;\n  });\n};\n\nexport interface GetPointByLocationParams extends CardLocationInfo {\n  cardAreaInfoArr: CardAreaInfo[];\n}\nconst getPointByLocation = ({ x, y, cardAreaInfoArr }: GetPointByLocationParams): paper.Point => {\n  const currentItem = cardAreaInfoArr.find((v) => v.x === x && v.y === y);\n  if (currentItem) {\n    return new paper.Point(currentItem.centerOffsetX, currentItem.centerOffsetY);\n  }\n  return new paper.Point(0, 0);\n};\n\nexport interface DrawActiveBorderParams {\n  location: CardLocationInfo;\n  cardAreaInfoArr: CardAreaInfo[];\n  color: paper.Color;\n  size?: paper.Size;\n  cardAreaSize: number;\n}\nexport const drawActiveBorder = ({\n  location,\n  color,\n  size,\n  cardAreaSize,\n  cardAreaInfoArr,\n}: DrawActiveBorderParams): paper.Group => {\n  const realSize = size || new paper.Size(cardAreaSize, cardAreaSize);\n  const lineWidth = 20;\n  const lineHeight = 4;\n  const { x: centerX, y: centerY } = getPointByLocation({ ...location, cardAreaInfoArr });\n  const startX = centerX - realSize.width / 2 - lineHeight;\n  const startY = centerY - realSize.height / 2 - lineHeight;\n\n  const path = new paper.Path();\n  path.lineTo(new paper.Point(startX, startY));\n  path.lineTo(new paper.Point(startX + lineWidth, startY));\n  path.lineTo(new paper.Point(startX + lineWidth, startY + lineHeight));\n  path.lineTo(new paper.Point(startX + lineHeight, startY + lineHeight));\n  path.lineTo(new paper.Point(startX + lineHeight, startY + lineWidth));\n  path.lineTo(new paper.Point(startX, startY + lineWidth));\n  path.lineTo(new paper.Point(startX, startY));\n\n  path.fillColor = color;\n\n  const leftBottomPath = path.clone();\n  leftBottomPath.rotate(270, new paper.Point(centerX, centerY));\n\n  const leftGroup = new paper.Group([path, leftBottomPath]);\n  const rightGroup = leftGroup.clone();\n\n  rightGroup.rotate(180, new paper.Point(centerX, centerY));\n  const borderGroup = new paper.Group([leftGroup, rightGroup]);\n  borderGroup.data = location;\n\n  return borderGroup;\n};\n\ninterface DrawCardParams {\n  cardAreaInfo: CardAreaInfo;\n  cardSize: number;\n}\nexport const drawCard = ({\n  cardAreaInfo,\n  cardSize,\n}: DrawCardParams): paper.Path.Circle | undefined => {\n  const { centerOffsetX, centerOffsetY, card } = cardAreaInfo;\n  if (!card) {\n    return undefined;\n  }\n\n  const { camp, displayName } = card;\n\n  const centerPointer = createPointer(centerOffsetX, centerOffsetY);\n\n  const cardPath = createCircle(centerPointer, cardSize);\n\n  const cardTextPath = new paper.PointText(centerPointer);\n  if (camp !== Camp.Unknow) {\n    cardTextPath.content = displayName;\n    cardTextPath.fontSize = animalCardConfig.cardSize;\n    cardTextPath.justification = 'center';\n    cardTextPath.translate(createPointer(0, 15));\n  }\n\n  cardPath.fillColor = new paper.Color(getCardColor(camp));\n  cardPath.shadowColor = new paper.Color('rgba(0, 0, 0, .8)');\n  cardPath.shadowOffset = createPointer(0, 0);\n  cardPath.shadowBlur = 5;\n\n  return cardPath;\n};\n","import { useEffect, useCallback } from 'react';\nimport { CardAreaInfo } from '../types';\nimport {} from 'react-use';\nimport { drawCard } from '../utils/drawPolygon';\n\ninterface UseAnimalCardsParams {\n  cardAreaInfoArr: CardAreaInfo[];\n  cardLayer: paper.Layer | null;\n}\nconst useAnimalCards = ({ cardAreaInfoArr, cardLayer }: UseAnimalCardsParams) => {\n  const drawCards = useCallback(() => {\n    const pathArr = cardAreaInfoArr.map((item) => {\n      return drawCard({\n        cardAreaInfo: item,\n        cardSize: 30,\n      });\n    });\n    return pathArr;\n  }, [cardAreaInfoArr]);\n\n  useEffect(() => {\n    cardLayer?.activate();\n\n    const pathArr = drawCards();\n\n    return () => {\n      pathArr.forEach((item) => item?.remove());\n    };\n  }, [cardLayer, cardAreaInfoArr, drawCards]);\n};\n\nexport default useAnimalCards;\n","import { useCallback } from 'react';\nimport { CardAreaInfo, CardLocationInfo, CardInfo } from '../types';\n\ninterface UseAnimalToolsParams {\n  cardAreaInfoArr: CardAreaInfo[];\n}\n\ninterface UseAnimalToolsReturn {\n  getCardInfoByLocation: (locationInfo: CardLocationInfo) => CardAreaInfo | undefined;\n  computedCardInfoByLocation: (\n    locationInfo: CardLocationInfo,\n    cardInfo: CardInfo,\n  ) => CardAreaInfo[];\n}\n\nconst useAnimalTools = ({ cardAreaInfoArr }: UseAnimalToolsParams): UseAnimalToolsReturn => {\n  const getCardInfoByLocation = useCallback<UseAnimalToolsReturn['getCardInfoByLocation']>(\n    (locationInfo) => {\n      const { x, y } = locationInfo;\n      return cardAreaInfoArr.find((item) => {\n        return item.x === x && item.y === y;\n      });\n    },\n    [cardAreaInfoArr],\n  );\n\n  const computedCardInfoByLocation = useCallback<\n    UseAnimalToolsReturn['computedCardInfoByLocation']\n  >(\n    (locationInfo, cardInfo) => {\n      const { x, y } = locationInfo;\n      return cardAreaInfoArr.map((item) => {\n        if (item.x === x && item.y === y) {\n          return {\n            ...item,\n            card: cardInfo,\n          };\n        }\n        return item;\n      });\n    },\n    [cardAreaInfoArr],\n  );\n\n  return {\n    getCardInfoByLocation,\n    computedCardInfoByLocation,\n  };\n};\n\nexport default useAnimalTools;\n","import { useEffect, useRef, useState } from 'react';\nimport paper from 'paper';\n\ninterface Layers {\n  gridLayer: null | paper.Layer;\n  cardLayer: null | paper.Layer;\n  operationLayer: null | paper.Layer;\n}\n\nconst usePaperLayer = () => {\n  const canvasEl = useRef<HTMLCanvasElement>();\n  const [layers, setLayers] = useState<Layers>({\n    gridLayer: null,\n    cardLayer: null,\n    operationLayer: null\n  });\n\n  useEffect(() => {\n    if (!canvasEl.current) return;\n    paper.setup(canvasEl.current);\n\n    const gridLayer = new paper.Layer();\n    const cardLayer = new paper.Layer();\n    const operationLayer = new paper.Layer();\n    \n    setLayers({\n      gridLayer,\n      cardLayer,\n      operationLayer\n    });\n  }, []);\n\n  return [canvasEl, layers] as const;\n};\n\nexport default usePaperLayer;\n","import { useRef, useCallback } from 'react';\nimport { CardInfo } from '../types';\nimport { generateCards } from '../utils/tools';\n\nconst useDealCards = () => {\n  const subCards = useRef<CardInfo[]>(generateCards());\n\n  const getCard = useCallback((): CardInfo | undefined => {\n    return subCards.current.shift();\n  }, []);\n\n  const resetCards = useCallback(() => {\n    subCards.current = generateCards();\n  }, []);\n\n  return {\n    getCard,\n    resetCards,\n  };\n};\n\nexport default useDealCards;\n","import { useEffect, useCallback, useState } from 'react';\n\nimport paper from 'paper';\n\nimport useEventCallback from '../../../hooks/useEventCallback';\nimport { drawGrid, drawCardArea, drawActiveBorder } from '../utils/drawPolygon';\nimport { createCardAreaInfoArr, fillCards } from '../utils/tools';\nimport { CardLocationInfo } from '../types';\n\nimport { animalLayoutSize, animalLayoutColor } from '../config';\n\nimport useAnimalCards from './useAnimalCards';\nimport useAnimalTools from './useAnimalTools';\nimport usePaperLayer from './usePaperLayer';\nimport useDealCards from './useDealCards';\n\nconst initCardAreaInfoArr = createCardAreaInfoArr({\n  ...animalLayoutSize,\n});\n\nconst useAnimalGrid: any = () => {\n  const [canvasEl, { gridLayer, cardLayer, operationLayer }] = usePaperLayer();\n  // const canvasEl = useRef<HTMLCanvasElement>(null);\n\n  const [activeArea, setActiveArea] = useState<CardLocationInfo | undefined>();\n  const [hoverArea, setHoverArea] = useState<CardLocationInfo | undefined>();\n\n  const [cardAreaInfoArr, setCardAreaInfoArr] = useState(initCardAreaInfoArr);\n\n  useAnimalCards({\n    cardAreaInfoArr,\n    cardLayer,\n  });\n\n  const { getCard } = useDealCards();\n\n  const { getCardInfoByLocation, computedCardInfoByLocation } = useAnimalTools({\n    cardAreaInfoArr,\n  });\n\n  useEffect(() => {\n    const pathArr = [\n      { location: activeArea, color: animalLayoutColor.activeBorderColor },\n      {\n        location: hoverArea,\n        color: animalLayoutColor.hoverBorderColor,\n      },\n    ].map((item) => {\n      if (item.location) {\n        operationLayer?.activate();\n        return drawActiveBorder({\n          location: item.location,\n          color: new paper.Color(item.color),\n          cardAreaInfoArr,\n          cardAreaSize: animalLayoutSize.cardAreaSize,\n        });\n      }\n      return undefined;\n    });\n\n    return () => {\n      pathArr.forEach((item) => item?.remove());\n    };\n  }, [operationLayer, activeArea, hoverArea]);\n\n  useEffect(() => {\n    setCardAreaInfoArr((data) => fillCards(data));\n  }, []);\n\n  const turnOverCard = useCallback(\n    (locationInfo: CardLocationInfo) => {\n      const cardAreaInfo = getCardInfoByLocation(locationInfo);\n      if (!cardAreaInfo?.card) return undefined;\n\n      const cardInfo = getCard();\n      if (!cardInfo) return undefined;\n\n      const newCardAreaInfoArr = computedCardInfoByLocation(locationInfo, {\n        ...cardInfo,\n      });\n\n      setCardAreaInfoArr(newCardAreaInfoArr);\n\n      return undefined;\n    },\n    [getCardInfoByLocation, computedCardInfoByLocation, setCardAreaInfoArr, getCard],\n  );\n\n  const onCardAreaMouseEnter = useEventCallback((locationInfo: CardLocationInfo) => {\n    setHoverArea(locationInfo);\n  }, []);\n\n  const onCardAreaMouseLeave = useEventCallback(() => {\n    setHoverArea(undefined);\n  }, []);\n\n  const onCardAreaMouseClick = useEventCallback(\n    (locationInfo: CardLocationInfo) => {\n      turnOverCard(locationInfo);\n\n      setActiveArea(locationInfo);\n    },\n    [turnOverCard],\n  );\n\n  const drawGridByLayoutSize = useCallback(() => {\n    gridLayer?.activate();\n    return drawGrid({ ...animalLayoutSize });\n  }, [gridLayer]);\n\n  const drawCardAreaByLayoutSize = useCallback(() => {\n    operationLayer?.activate();\n    return drawCardArea({\n      cardAreaInfoArr,\n      cardAreaSize: animalLayoutSize.cardAreaSize,\n      onCardAreaMouseEnter,\n      onCardAreaMouseLeave,\n      onCardAreaMouseClick,\n    });\n  }, [\n    cardAreaInfoArr,\n    operationLayer,\n    onCardAreaMouseEnter,\n    onCardAreaMouseLeave,\n    onCardAreaMouseClick,\n  ]);\n\n  const setup = useEventCallback(() => {\n    return drawGridByLayoutSize().concat(drawCardAreaByLayoutSize());\n  }, [drawGridByLayoutSize, drawCardAreaByLayoutSize]);\n\n  useEffect(() => {\n    if (canvasEl.current) {\n      const pathArr = setup();\n      return () => {\n        pathArr.forEach((item) => item.remove());\n      };\n    }\n    return () => {};\n  }, [canvasEl.current, setup]);\n\n  return [canvasEl];\n};\n\nexport default useAnimalGrid;\n","import React from 'react';\nimport useAnimalGrid from './hooks/useAnimalGrid';\nimport './style.css';\n\nconst Playground: React.FC<{}> = () => {\n  const [canvasEl] = useAnimalGrid();\n\n  return (\n    <div>\n      <canvas ref={canvasEl} id=\"animal-canvas\" />\n    </div>\n  );\n};\n\nexport default Playground;\n","import React from 'react';\nimport Playground from './pages/Playground';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Playground />\n    </div>\n  );\n}\n\nexport default App;\n","/* eslint-disable */\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/),\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}